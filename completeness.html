<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UK Rain Gauge Record Completeness per 1 km</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <!-- Styles for map and dropdown -->
    <style>
        #map {
            height: 500px;
            width: 100%;
        }

        select {
            margin: 10px;
            padding: 10px;
        }
    </style>
</head>
<body>
    <!-- Dropdown for selecting year -->
    <div style="display: flex; align-items: center; gap: 10px;">
        <label for="year-select" style="font-size: 14px;"><h2>Select Year:</h2></label>
        <select id="year-select" style="font-size: 14px; padding: 5px; width: auto;"></select>
        <h2 style="flex-grow: 1; text-align: center; margin: 0; margin-left: -20px;">Rain gauges (1 day)</h2>
    </div>

    <script>
        let lastYear = 2023; // Keep track of the last year in the loop

        // Generate a list of years from 1953 to 2023 with a step of 5
        const yearSelect = document.getElementById('year-select');
        for (let year = 1953; year <= lastYear; year += 5) {
            let option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            // Set the last value as the default selection
            if (year === lastYear) {
                option.selected = true;
            }
            yearSelect.appendChild(option);
        }

        // Handle selection change (you can customize the behavior here)
        yearSelect.addEventListener('change', function() {
            console.log("Selected Year: " + yearSelect.value);
            // You can trigger other functions or update data here based on the selected year
        });
    </script>

    <!-- Map container -->
    <div id="map"></div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        // Initialize the map with EPSG:4326 CRS (WGS84)
        var map = L.map('map').setView([53.5074, -0.8], 5);  // Set initial view to London (lat, lng)

        // Set the tile layer (OpenStreetMap or your own tile service)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Function to load GeoJSON based on the year selected
        function loadGeoJSON(year) {
            // Clear existing GeoJSON layers
            map.eachLayer(function(layer) {
                if (layer instanceof L.GeoJSON) {
                    map.removeLayer(layer);
                }
            });

            // Function to set color based on property value
            function getColor(value) {
                if (value === null || value === undefined) return 'transparent'; // Hide if no value
                const minValue = 0;    // Min value
                const maxValue = 100;  // Max value
                
                // For values below 90, use a smoother linear scale
                let scaleValue = value;
                
                // Apply a power scaling after 90 for a better distinction between 90-100
                if (value >= 90) {
                    scaleValue = 90 + Math.pow((value - 90), 1.5);  // Apply power scaling after 90
                }
                
                // Normalize to a range between 0 and 1
                const normalizedValue = (scaleValue - minValue) / (maxValue - minValue);
            
                // Define a color scale from light blue to dark blue
                const colors = [
                    "#f7fbff", "#e1effd", "#c3e1fb", "#a4d4f9", "#86c7f7", 
                    "#68baf5", "#4aaef3", "#2ca1f1", "#0994ef", "#0088e5",
                    "#007bdc", "#006fd2", "#0063c9", "#0057bf", "#004ba6", 
                    "#00408c", "#003678", "#002c64", "#002350", "#001b3c"
                ];
            
                // Map the normalized value to a color
                const colorIndex = Math.min(Math.floor(normalizedValue * (colors.length - 1)), colors.length - 1);
            
                return colors[colorIndex]; // Return the corresponding color
            }

            // Function to style each feature
            function style(feature) {
                return {
                    fillColor: getColor(feature.properties.completeness), // Color based on property
                    weight: 0,
                    opacity: 1,
                    color: 'black',
                    dashArray: '3',
                    fillOpacity: 0.7
                };
            }

           // Add tooltips on hover and make it permanent on click
           function onEachFeature(feature, layer) {
                let tooltip;  // Variable to store the tooltip for each polygon

                // Tooltip on hover (brief)
                layer.on('mouseover', function(e) {
                    tooltip = layer.bindTooltip(`Mean gauge completeness: ${feature.properties.completeness}`, {
                        permanent: false,        // Tooltip disappears after hover ends
                        direction: "top",
                        offset: [0, -5]
                    }).openTooltip();
                });

                // Tooltip disappears on mouseout
                layer.on('mouseout', function(e) {
                    if (!layer._tooltip.options.permanent) {
                        layer.closeTooltip();
                    }
                });
            }

            // Determine the correct GeoJSON file for the selected year
            var geojsonFile = `completeness_maps_${year}.geojson`;

            // Load GeoJSON and apply styling
            fetch(`completeness_maps/${geojsonFile}`)
                .then(response => response.json())
                .then(data => {
                    L.geoJSON(data, {
                        style: style,
                        onEachFeature: onEachFeature // Attach tooltips
                     }).addTo(map);
                })
                .catch(error => console.error('Error loading GeoJSON:', error));
        }

        // Initially load the GeoJSON for first map
        loadGeoJSON('2023');

        // Update the map when the user selects a different year
        document.getElementById('year-select').addEventListener('change', function(event) {
            loadGeoJSON(event.target.value);
        });
    </script>

</body>
</html>
