<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UK Rain Gauges - Quality Control summary</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <!-- Styles for map and dropdown -->
    <style>
        #map {
            height: 500px;
            width: 100%;
        }

        select {
            margin: 20px;
            padding: 10px;
        }
        .legend {
            line-height: 18px;
            color: #555;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            font-size: 12px;
        }
        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
        }

        mark.blue {
            color:#31b3ff;
            background: none;
        }
    </style>
</head>
<body>
    <!-- Dropdown for selecting year -->
    <div style="display: flex; align-items: center; gap: 10px;">
        <label for="qc-select" style="font-size: 14px;"><h2>Select QC method:</h2></label>
        <select id="qc-select" style="font-size: 14px; padding: 5px; width: auto;">
            <option value="perc_flagged">perc_flagged</option>
            <option value="total_flagged_rows">total_flagged_rows</option>
            <option value="total_rows">percentiles_zero</option>
            <option value="percentiles_zero">total_rows</option>
            <option value="k-largest_zero">k-largest_zero</option>
            <option value="days_of_week">days_of_week</option>
            <option value="hours_of_day">hours_of_day</option>
            <option value="intermittency">intermittency</option>
            <option value="min_val_change">min_val_change</option>
            <option value="r99p">r99p</option>
            <option value="prcptot">prcptot</option>
            <option value="timings_offset">timings_offset</option>
            <option value="affinity_index">affinity_index</option>
            <option value="pearson_corr">pearson_corr</option>
            <option value="world_record_check">world_record_check</option>
            <option value="rx1day_check">rx1day_check</option>
            <option value="dry_spell_flag">dry_spell_flag</option>
            <option value="monthly_accumulation">monthly_accumulation</option>
            <option value="streak_flag1">streak_flag1</option>
            <option value="streak_flag3">streak_flag3</option>
            <option value="streak_flag4">streak_flag4</option>
            <option value="streak_flag5">streak_flag5</option>
            <option value="wet_spell_flag_hourly">wet_spell_flag_hourly</option>
            <option value="dry_spell_flag_hourly">dry_spell_flag_hourly</option>
        </select>
        <label for="data-select" style="font-size: 14px;"><h2>Select data:</h2></label>
        <select id="data-select" style="font-size: 14px; padding: 5px; width: auto;">
            <option value="15min">15 mins</option>
            <option value="1hr">1 hour</option>
        </select>
    </div>

    <!-- Map container -->
    <div id="map"></div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        function formatNumber(num) {
            if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(1) + 'k';
            return Math.round(num).toString();
        }

        var map = L.map('map').setView([53.5074, -0.8], 5);  // Set initial view to London (lat, lng)

        // Set the tile layer (OpenStreetMap)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        let currentGeoJsonLayer = null;
        let gridLayer = null;
        let gridData = null;
        let tooltipsVisible = true;

        const qcLabels = {
            perc_flagged: 'Percent Flagged',
            total_flagged_rows: 'Total Flagged Rows',
            // Add more if needed
        };

        function getColor(value, min, max) {
            if (value === null || value === undefined || isNaN(value)) return 'transparent';
            if (max === min) return '#8000ff'; // edge case: all values same

            const colors = [
                '#f2e5ff', '#e5ccff', '#d9b3ff', '#cc99ff', '#bf80ff',
                '#b366ff', '#a64dff', '#9933ff', '#8000ff', '#6600cc'
            ];

            // Normalize value to a range of 0 to 1
            const normalized = (value - min) / (max - min);
            const index = Math.floor(normalized * (colors.length - 1));

            return colors[Math.max(0, Math.min(colors.length - 1, index))];
        }

        function loadRainGauges(selectedQC, frequency) {
            const geojsonFile = `qc_data/UK_${frequency}_QC_summary_4326.geojson`;

            fetch(geojsonFile)
                .then(res => res.json())
                .then(data => {
                    if (gridLayer) {
                        map.removeLayer(gridLayer);
                    }

                    const values = data.features
                        .map(f => f.properties[selectedQC])
                        .filter(v => v !== null && v !== undefined && !isNaN(v));

                    const min = Math.min(...values);
                    const max = Math.max(...values);

                    gridLayer = L.geoJSON(data, {
                        pointToLayer: (feature, latlng) => {
                            const value = feature.properties[selectedQC];
                            const fillColor = getColor(value, min, max); // Use scaled color

                            const tooltip = `
                                <strong>${feature.properties.SITE_NAME}</strong><br>
                                <b>Station ID:</b> ${feature.properties.station_id}<br>
                                <b>Operator:</b> ${feature.properties.OPERATOR_ID}<br>
                                <mark class="blue";><b>${selectedQC}:</b> ${value ?? "No data"}</mark><br>
                                <i>Click for more info...</i>
                            `;

                            return L.circleMarker(latlng, {
                                radius: 8,
                                color: 'black',
                                weight: 1,
                                fillColor: fillColor,
                                fillOpacity: 0.8
                            }).bindTooltip(tooltip, { permanent: false });
                        },
                        onEachFeature: (feature, layer) => {
                            const value = feature.properties[selectedQC];
                            const popupContent = `
                                <strong>${feature.properties.SITE_NAME}</strong><br>
                                <b>Station ID:</b> ${feature.properties.station_id}<br>
                                <mark class="blue";><b>${selectedQC}:</b> ${value ?? "No data"}</mark><br>
                                <b>Operator:</b> ${feature.properties.OPERATOR_ID}<br>
                                <b>Start Date:</b> ${new Date(feature.properties.start_datetime).toLocaleDateString()}<br>
                                <b>End Date:</b> ${new Date(feature.properties.end_datetime).toLocaleDateString()}<br>
                                <b>Completeness:</b> ${feature.properties.COMPLETENESS}<br>
                                <b>Flagged rows (%):</b> ${feature.properties.perc_flagged}<br>
                                <b>Nearby gauges (&lt;30km):</b> ${feature.properties.num_nearby_gauges_30km}
                            `;
                            layer.on('click', () => {
                                layer.bindPopup(popupContent).openPopup();
                            });
                        }
                    }).addTo(map);

                    addLegend(selectedQC, min, max);
                })
                .catch(err => console.error('Error loading rain gauge GeoJSON:', err));
        }

        function addLegend(selectedQC, min, max) {
            if (window.currentLegend) {
                map.removeControl(window.currentLegend);
            }

            const qcLabels = {
                perc_flagged: 'perc_flagged',
                total_flagged_rows: 'total_flagged_rows',
                percentiles_zero: 'percentiles_zero',
                total_rows: 'total_rows',
                k_largest_zero: 'k-largest_zero',
                days_of_week: 'days_of_week',
                hours_of_day: 'hours_of_day',
                intermittency: 'intermittency',
                min_val_change: 'min_val_change',
                r99p: 'r99p',
                prcptot: 'prcptot',
                timings_offset: 'timings_offset',
                affinity_index: 'affinity_index',
                pearson_corr: 'pearson_corr',
                world_record_check: 'world_record_check',
                rx1day_check: 'rx1day_check',
                dry_spell_flag: 'dry_spell_flag',
                monthly_accumulation: 'monthly_accumulation',
                streak_flag1: 'streak_flag1',
                streak_flag3: 'streak_flag3',
                streak_flag4: 'streak_flag4',
                streak_flag5: 'streak_flag5',
                wet_spell_flag_hourly: 'wet_spell_flag_hourly',
                dry_spell_flag_hourly: 'dry_spell_flag_hourly'
            };

            const legend = L.control({ position: 'bottomright' });

            legend.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'info legend');
                const title = qcLabels[selectedQC] || selectedQC;
                div.innerHTML = `<strong>${title}</strong><br>`;

                const rangeMin = min ?? 0;
                const rangeMax = max ?? 100;

                // Prevent edge case
                if (rangeMax === rangeMin) {
                    div.innerHTML += `<i style="background:${getColor(rangeMin, min, max)}"></i> ${rangeMin}`;
                    return div;
                }

                const numBins = 10;
                const step = (rangeMax - rangeMin) / numBins;
                const grades = Array.from({ length: numBins }, (_, i) => rangeMin + i * step);

                grades.forEach((from, i) => {
                    const to = i < grades.length - 1 ? grades[i + 1] : rangeMax;
                    div.innerHTML += `
                        <i style="background:${getColor(from, rangeMin, rangeMax)}"></i>
                        ${formatNumber(from)}â€“${formatNumber(to)}<br>
                    `;
                });

                return div;
            };

            legend.addTo(map);
            window.currentLegend = legend;
        }

        // Initial load
        // Initially load the GeoJSON for first map
        loadRainGauges('perc_flagged', '15min');

        window.addEventListener('DOMContentLoaded', () => {
            const selectedQC = document.getElementById('qc-select').value;
            const selectedFrequency = document.getElementById('data-select').value;
            loadRainGauges(selectedFrequency, selectedQC);
        });

        document.getElementById('qc-select').addEventListener('change', () => {
            const selectedQC = document.getElementById('qc-select').value;
            const selectedFrequency = document.getElementById('data-select').value;
            loadRainGauges(selectedQC, selectedFrequency);
        });

        document.getElementById('data-select').addEventListener('change', () => {
            const selectedQC = document.getElementById('qc-select').value;
            const selectedFrequency = document.getElementById('data-select').value;
            loadRainGauges(selectedQC, selectedFrequency);
        });
    </script>
<div>The rain gauge network is incomplete. Only what is on the UKCEH database.</div>
</body>
</html>
