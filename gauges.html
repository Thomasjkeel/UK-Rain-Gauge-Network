<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number of UK Rain Gauges per 1 km</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <!-- Styles for map and dropdown -->
    <style>
        #map {
            height: 500px;
            width: 100%;
        }

        select {
            margin: 20px;
            padding: 10px;
        }
    </style>
</head>
<body>
    <!-- Dropdown for selecting year -->
    <div style="display: flex; align-items: center; gap: 10px;">
        <label for="year-select" style="font-size: 14px;"><h2>Select Year:</h2></label>
        <select id="year-select" style="font-size: 14px; padding: 5px; width: auto;"></select>
        <label for="grid-select" style="font-size: 14px;"><h2>Select grid:</h2></label>
        <select id="grid-select" style="font-size: 14px; padding: 5px; width: auto;"></select>
        <button id="toggle-grid-points" style="margin: 10px; padding: 10px; font-size: 14px;">
            Show Grid Points
        </button>
        <h2 style="flex-grow: 1; text-align: left; margin: 0; margin-left: 40px;">Rain gauges (1 day)</h2>

    </div>

    <script>
        let lastYear = 2023; // Keep track of the last year in the loop

        // Generate a list of years from 1953 to 2023 with a step of 5
        const yearSelect = document.getElementById('year-select');
        for (let year = 1953; year <= lastYear; year += 5) {
            let option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            // Set the last value as the default selection
            if (year === lastYear) {
                option.selected = true;
            }
            yearSelect.appendChild(option);
        }

        // Handle selection change (you can customize the behavior here)
        yearSelect.addEventListener('change', function() {
            console.log("Selected Year: " + yearSelect.value);
            // You can trigger other functions or update data here based on the selected year
        });


        const gridSelect = document.getElementById('grid-select');
        const gridOptions = ["1 km grid", "5 km grid"];

        gridOptions.forEach(grid => {
            let option = document.createElement('option');
            option.value = grid;
            option.textContent = grid;

            // Set default selection to "1d"
            if (grid === "1 km grid") {
                option.selected = true;
            }
            gridSelect.appendChild(option);
        });
        // Handle selection change
        gridSelect.addEventListener('change', function() {
            console.log("Selected data: " + gridSelect.value);
            // Call your update function here
        });

    </script>

    <!-- Map container -->
    <div id="map"></div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        // Initialize the map with EPSG:4326 CRS (WGS84)
        var map = L.map('map').setView([53.5074, -0.8], 5);  // Set initial view to London (lat, lng)

        // Set the tile layer (OpenStreetMap or your own tile service)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Function to load GeoJSON based on the year selected
        function loadGeoJSON(year) {
            // Clear existing GeoJSON layers
            map.eachLayer(function(layer) {
                if (layer instanceof L.GeoJSON) {
                    map.removeLayer(layer);
                }
            });

            function getColor(value) {
                if (value === null || value === undefined) return 'transparent'; // Hide if no value

                // Define a range of colors from light purple to dark purple
                const colors = [
                    '#f2f0f7', '#e0d9f4', '#d0bdf0', '#c1a1ec', '#b384e8', // 0-5
                    '#a26ce4', '#9147e0', '#8030dc', '#6f1ad7', '#5e00d2', // 6-10
                    '#4d00cc', '#3c00c6', '#2b00c0', '#1a00ba', '#0900b4', // 11-15
                    '#0b00a7', '#1b009a', '#2b008d', '#3b007f', '#4b006a', // 16-20
                    '#5b0055', '#6b0040', '#7b002b', '#8b0016', '#9b0000', // 21-25
                    '#9b0000', '#8b1c00', '#7b3900', '#6b5500', '#5b7100', // 26-30
                    '#4b8d00', '#3b9900', '#2ba500', '#1b6100', '#0b1d00'  // 31-35
                ];

                value = Math.max(0, Math.min(35, value)); // Keep values in range 0 to 35

                return colors[Math.floor(value)]; // Map value 0-35 to the color array
            }


            // Function to style each feature
            function style(feature) {
                return {
                    fillColor: getColor(feature.properties.num_gauges), // Color based on property
                    weight: 0,
                    opacity: 1,
                    color: 'black',
                    dashArray: '3',
                    fillOpacity: 0.7
                };
            }

           // Add tooltips on hover and make it permanent on click
           function onEachFeature(feature, layer) {
                let tooltip;  // Variable to store the tooltip for each polygon

                let numGauges = feature.properties.num_gauges;
                let tooltipLabel = numGauges !== null ? 
                    `Number of gauges: ${numGauges}` : 
                    "No rain gauges";
                if (numGauges == 0) {
                        tooltipLabel = "No rain gauges";
                }
    

                // Tooltip on hover (brief)
                layer.on('mouseover', function(e) {
                    tooltip = layer.bindTooltip(tooltipLabel, {
                        permanent: false,        // Tooltip disappears after hover ends
                        direction: "top",
                        offset: [0, -5]
                    }).openTooltip();
                });

                // Tooltip disappears on mouseout
                layer.on('mouseout', function(e) {
                    if (!layer._tooltip.options.permanent) {
                        layer.closeTooltip();
                    }
                });
            }

            // Determine the correct GeoJSON file for the selected year
            var geojsonFile = `num_gauges_${year}.geojson`;

            // Load GeoJSON and apply styling
            fetch(`num_gauges_gridded/${geojsonFile}`)
                .then(response => response.json())
                .then(data => {
                    L.geoJSON(data, {
                        style: style,
                        onEachFeature: onEachFeature // Attach tooltips
                     }).addTo(map);
                })
                .catch(error => console.error('Error loading GeoJSON:', error));
        }

        var gridData = null; // Store loaded GeoJSON data
        var gridLayer = null; // Store grid layer to toggle visibility
        var gridDataLoaded = false; // Track if data is already loaded

        function toggleGridPoints() {
            let selectedYear = parseInt(document.getElementById('year-select').value);

            if (gridLayer) {
                map.removeLayer(gridLayer);
                gridLayer = null;
                document.getElementById('toggle-grid-points').textContent = "Show Grid Points";
            } else {
                if (!gridDataLoaded) {
                    // Fetch GeoJSON only the first time
                    fetch('uk_gauges/GB_rain_gauges_1d_4326.geojson') // Adjust path if needed
                        .then(response => response.json())
                        .then(data => {
                            gridData = data; // Store full dataset
                            gridDataLoaded = true;
                            showFilteredGridPoints(selectedYear);
                        })
                        .catch(error => console.error('Error loading GeoJSON:', error));
                } else {
                    showFilteredGridPoints(selectedYear);
                }
            }
        }

        function showFilteredGridPoints(selectedYear) {
            if (!gridData) return;

            let filteredFeatures = gridData.features.filter(feature => {
                let startDate = parseInt(feature.properties.START_DATE);
                let endDate = parseInt(feature.properties.END_DATE);
                return selectedYear >= startDate && selectedYear <= endDate;
            });

            gridLayer = L.geoJSON({ type: "FeatureCollection", features: filteredFeatures }, {
                pointToLayer: function (feature, latlng) {
                    // Format tooltip content
                    let tooltipContent = `
                        <strong>${feature.properties.SITE_NAME}</strong><br>
                        <b>Site ID:</b> ${feature.properties.SITE_ID}<br>
                        <b>Data Coverage:</b> ${feature.properties.DATA_PCT}%<br>
                        <b>Start Date:</b> ${new Date(feature.properties.START_DATE).toLocaleDateString()}<br>
                        <b>End Date:</b> ${new Date(feature.properties.END_DATE).toLocaleDateString()}
                    `;
                    return L.circleMarker(latlng, {
                        radius: 8,
                        fillColor: "none",
                        color: "black",
                        weight: 0.5,
                        fillOpacity: 0
                    }).bindTooltip(tooltipContent, { permanent: false });
                }
            }).addTo(map);

            document.getElementById('toggle-grid-points').textContent = "Hide Grid Points";
        }

        // Ensure points update when year changes
        document.getElementById('year-select').addEventListener('change', function () {
            if (gridLayer) {
                map.removeLayer(gridLayer);
                gridLayer = null;
                showFilteredGridPoints(parseInt(this.value));
            }
        });
        // Initially load the GeoJSON for first map
        loadGeoJSON('2023');

        // Update the map when the user selects a different year
        document.getElementById('year-select').addEventListener('change', function(event) {
            loadGeoJSON(event.target.value);
        });
        document.getElementById('toggle-grid-points').addEventListener('click', toggleGridPoints);

    </script>

</body>
</html>
